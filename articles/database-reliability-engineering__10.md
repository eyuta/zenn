---
title: "【10章】データベースリライアビリティエンジニアリングの読書メモ"
emoji: "😺"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["oreilly", "DBRE"]
published: true
---

# DBRE 輪読会 vol.10 <!-- omit in toc -->

<!-- _class: lead -->

2021/09/09

~ストレージ、インデックス、レプリケーション~

## おさらい<!-- omit in toc -->

1 章:学習を続け、チームを超えて改善を進める
2 章:SLO が全ての基礎
3 章:SLO のためにリスクを認識し低減する
4 章:SLO への影響を知るための⾒える化
5 章:インフラ構築の実践
6 章:インフラ構築の管理
7 章:リスクに応じたバックアップ・リカバリの実践
8 章:DB の安全なリリースのための施策
9 章:データを守る

<!-- _class: lead -->

## この章で学ぶこと<!-- omit in toc -->

ここまではデータベースの運用方法について。
ここからは、データベースの重要な機能である「データの格納」について詳しく見ていく。

おすすめ図書:
[データ指向アプリケーションデザイン](https://www.oreilly.co.jp/books/9784873118703/)

## 目次<!-- omit in toc -->

- [10.1 データ構造のストレージ](#101-データ構造のストレージ)
  - [10.1.1 データベースの行ストレージ](#1011-データベースの行ストレージ)
    - [バイナリツリー構造](#バイナリツリー構造)
  - [10.1.2 ストアドストリングテーブルとログ構造のマージツリー](#1012-ストアドストリングテーブルとログ構造のマージツリー)
  - [10.1.3 インデックスの生成](#1013-インデックスの生成)
    - [ハッシュインデックス](#ハッシュインデックス)
    - [ビットマップインデックス](#ビットマップインデックス)
    - [バイナリツリーにおける並び替え](#バイナリツリーにおける並び替え)
- [10.2 データのレプリケーション](#102-データのレプリケーション)
  - [10.2.1 単一リーダーによるレプリケーション](#1021-単一リーダーによるレプリケーション)
  - [10.2.2 複数リーダーのレプリケーション](#1022-複数リーダーのレプリケーション)
- [10.3 まとめ](#103-まとめ)

## 10.1 データ構造のストレージ

伝統的なデータベースは、テーブルとインデックスの組み合わせでデータを保存する。

- テーブル
  - 主な記憶メカニズム
- インデックス
  - アクセス時間を改善するために順序付けられたサブセット

<!--
伝統的にデータベースは、テーブルとインデックスの組み合わせでデータを保存してきました。
テーブルは主な記憶メカニズムであり、インデックスはアクセス時間を改善するために順序づけられたデータの最適化されたサブセットです。
データがどのようにストレージから読み書きされるかを理解することは、ストレージおよびデータベースの構成と最適化をするうえで重要です。
ストレージと入出力（I/O）の仕様を考慮に入れ、ディスクおよびインデックスでデータがどのようにやりとりされるかを考慮に入れなければなりません。
-->

### 10.1.1 データベースの行ストレージ

データはブロック（or ページ）呼ばれるものに格納される。

- ブロック
  - ディスク上の特定のバイト列に対応している。
  - データを格納する最小単位
  - データのほかにメタデータを保持
    - ディスク上のアドレス情報、ブロックに対するアクティビティ情報等
  - エクステントと呼ばれる、より大きな入れものの単位で管理されることがある
- エクステント

> ![cncpt027](https://docs.oracle.com/cd/B19306_01/server.102/b14220/img/cncpt027.gif)

引用: [Data Blocks, Extents, and Segments](https://docs.oracle.com/cd/B19306_01/server.102/b14220/logical.htm)

<!--
まずは、データ構造の概要から始めます。
リレーショナルデータベースにおいてデータは、ブロックもしくはページと呼ばれる入れものに格納されます。ブロックもしくはページは、ディスク上の特定のバイト列に対応しています。データベースによって用語がブロックやページだったりしますが、指しているものは同じです。

ブロックはデータを格納する最小単位です。
また、ブロックはデータにアクセスするさいに使用可能な最小単位です。
例えばブロックサイズが16KBだった場合、データのサイズが 1KB であったとしても、読み込みにはブロックサイズの 16KB が必要になります。
データベースのブロックサイズが、ファイルシステムのブロックサイズよりも小さい場合、複数のページを無駄に消費することになり、I/O オペレーションにおいて無駄が発生することになります。

ブロックは、データのほかにメタデータを保持しています。これにはヘッダやトレイラー／フッタが含まれ、ディスク上のアドレス情報、オブジェクトがどのブロックに配置されているか、そのブロックの行に対するアクティビティの情報が保存されています。
データブロックは、エクステントと呼ばれる、より大きな入れものの単位で管理されることがあります。テーブル領域に、新たに割り当てが必要になった場合、効率化のためにエクステントが単位となって新しいブロックの割り当てを行います。
テーブル領域は、もっとも大きいデータ構造であり、1 つまたは 2 つの物理ファイルとして、ディスク上に保存されます。
システム上は物理ディスクに直接マッピングされますが、テーブル領域のファイルは I/O コストを下げるため、異なるディスクにまたがって配置されることもあります。
 -->

#### バイナリツリー構造

多くのデータベースでは、データをバイナリツリー（B-tree）のフォーマットで構造化している。

- バイナリツリー構造
  - データが増え続ける場合でも自分でバランシング（二分探索）する
  - データブロックの読み書き、そしてファイルシステムやデータベース向けの構造
  - [B+tree](https://ja.wikipedia.org/wiki/B%2B%E6%9C%A8)や[B\*-tree](https://ja.wikipedia.org/wiki/B*%E6%9C%A8)といった改良版も存在する

---

※注: 本著では`バイナリツリー=B-tree`となるが、`バイナリツリー=binary tree=二分木`と`B-tree=self-balancing binary search tree=平衡二分探索木`は別物のようです。本著では、`B-tree`の意味として使われているように感じます。
参考: [B 木 - Wikipedia](https://ja.wikipedia.org/wiki/B%E6%9C%A8)

---

- バイナリツリーが持つ特性と利点
  - 範囲ベースのクエリに対して高パフォーマンス
  - 単一行ベースの検索に対しては、もっとも理想的なモデルというわけではない(後述)
  - ソートされたキーに対しては、検索と範囲スキャンは効率的に実施できる
  - 大規模データセットにおいてページの読み込みを最小に抑えられる
  - ページごとにキーを格納する必要がないので、削除と挿入が効率的に実施できる
  - バイナリツリーがメモリにすべて載る場合は、極めてよいパフォーマンスを発揮する

### 10.1.2 ストアドストリングテーブルとログ構造のマージツリー

<!-- 次に、上述したブロックストレージと異なるデータストレージ構造として、Sorted String Table（SSTable）エンジンについて紹介します。 -->

---

※注: おそらく訳ミスで、`ストアドストリングテーブル:Stored String Table`ではなく`Sorted String Table（SSTable）`

---

- SSTable
  - 以下のようなデータベースのプライマリストレージとして機能するストレージエンジン
    - Apache Cassandra
    - Google Bigtable
    - HBase
    - LevelDB
    - Lucene
    - Riak
    - RocksDB
    - WiredTiger
  - ペアとなるキーと値がソートされた多数のファイルを保持している
  - ブロックストレージとは異なり、オーバーヘッドとなるメタデータは存在しない

ストアドストリングテーブルエンジンは、

- データをすべてメモリ上に保持するインメモリテーブル
- データをひとまとめ（バッチ）にしたディスク同期（フラッシュ）
- 定期的に実行されるコンパクション

といったアルゴリズムを組み合わせて動作する。
このアルゴリズムは、**ログ構造マージ（LSM）ツリーアーキテクチャ**とも呼ばれる。

> ![10_01](https://github.com/eyuta/zenn/blob/master/out/articles/database-reliability-engineering__10_01.png?raw=true)

引用: データベースリライアビリティエンジニアリング P204

<!--
ここまで、データストレージ構造をいくつか紹介してきました。その中では、ログについてもた
びたび触れてきました。障害発生時の可用性を担保するためにログが果たす役割は重要です。ま
た、7 章でも触れた通り、レプリケーション機能でもログは大きな役目を持っています。以下から
は、ログとレプリケーションについて深掘りしていきます。
 -->

### 10.1.3 インデックスの生成

#### ハッシュインデックス

検索キーをハッシュ関数でハッシュ化し、その値とレコードを紐付けて格納する（=ハッシュマップ）。
検索時は、検索キーのハッシュ値に基づいてレコードを取得する。

> ![image-126.png](https://codingsight.com/wp-content/uploads/2021/06/image-126.png)

参考: [Hash Index: Everything you Need to Know about Hashing](https://codingsight.com/hash-index-understanding-hash-indexes/)

- デメリット
  - ハッシュマップ自体がメモリに載せられるサイズである必要がある
  - 単一キーでの検索となるため、範囲検索には向かない

#### ビットマップインデックス

データをビットマップの配列として保持する。
バイナリツリーインデックスと異なり、カーディナリティ（データ濃度）が低い（=取りうる値の種類が少ない）場合に有効。

#### バイナリツリーにおける並び替え

バイナリツリーインデックスの並び替え（ソート）手法には様々なものがあるが、用途によって使い分ける必要がある。

- 関数ベースの並び替え
  - 任意の関数で並び替えを行ったインデックス
- 逆インデックス
  - ソート順を逆向きにしたインデックス
- クラスタリングされたインデックス
  - I/O 最適化のためにテーブルを物理的に保存しているインデックス
  - バイナリツリーの葉ノードは、クラスタリングされたそれぞれにデータページを保持する
- 空間インデックス
  - R-Tree（R 木）がよく使われる
  - R: Rectangle
  - 多次元情報のインデックス付けに使用される
  - 参考: [空間インデックス - Wikipedia](https://ja.wikipedia.org/wiki/%E7%A9%BA%E9%96%93%E3%82%A4%E3%83%B3%E3%83%87%E3%83%83%E3%82%AF%E3%82%B9)
- サーチインデックス
  - カラム内のサブセットとしての情報を検索するのに適したインデックス
  - インデックス化された値に対して検索できる
  - 例: ElasticSearch

## 10.2 データのレプリケーション

### 10.2.1 単一リーダーによるレプリケーション

### 10.2.2 複数リーダーのレプリケーション

## 10.3 まとめ
