---
title: "【10章】データベースリライアビリティエンジニアリングの読書メモ"
emoji: "😺"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["oreilly", "DBRE"]
published: true
---

# DBRE 輪読会 vol.10 <!-- omit in toc -->

<!-- _class: lead -->

2021/09/09

~ストレージ、インデックス、レプリケーション~

## おさらい<!-- omit in toc -->

1 章:学習を続け、チームを超えて改善を進める
2 章:SLO が全ての基礎
3 章:SLO のためにリスクを認識し低減する
4 章:SLO への影響を知るための⾒える化
5 章:インフラ構築の実践
6 章:インフラ構築の管理
7 章:リスクに応じたバックアップ・リカバリの実践
8 章:DB の安全なリリースのための施策
9 章:データを守る

<!-- _class: lead -->

## この章で学ぶこと<!-- omit in toc -->

ここまではデータベースの運用方法について。
ここからは、データベースの重要な機能である「データの格納」について詳しく見ていく。

おすすめ図書:
[データ指向アプリケーションデザイン](https://www.oreilly.co.jp/books/9784873118703/)

## 目次<!-- omit in toc -->

- [10.1 データ構造のストレージ](#101-データ構造のストレージ)
  - [10.1.1 データベースの行ストレージ](#1011-データベースの行ストレージ)
    - [バイナリツリー構造](#バイナリツリー構造)
  - [10.1.2 ストアドストリングテーブルとログ構造のマージツリー](#1012-ストアドストリングテーブルとログ構造のマージツリー)
  - [10.1.3 インデックスの生成](#1013-インデックスの生成)
    - [ハッシュインデックス](#ハッシュインデックス)
    - [ビットマップインデックス](#ビットマップインデックス)
    - [バイナリツリーにおける並び替え](#バイナリツリーにおける並び替え)
- [10.2 データのレプリケーション](#102-データのレプリケーション)
  - [10.2.1 単一リーダーによるレプリケーション](#1021-単一リーダーによるレプリケーション)
  - [10.2.2 複数リーダーのレプリケーション](#1022-複数リーダーのレプリケーション)
- [10.3 まとめ](#103-まとめ)

## 10.1 データ構造のストレージ

伝統的なデータベースは、テーブルとインデックスの組み合わせでデータを保存する。

- テーブル
  - 主な記憶メカニズム
- インデックス
  - アクセス時間を改善するために順序付けられたサブセット

<!-- 伝統的にデータベースは、テーブルとインデックスの組み合わせでデータを保存してきました。 -->
<!-- テーブルは主な記憶メカニズムであり、インデックスはアクセス時間を改善するために順序づけられたデータの最適化されたサブセットです。 -->
<!-- データがどのようにストレージから読み書きされるかを理解することは、ストレージおよびデータベースの構成と最適化をするうえで重要です。 -->
<!-- ストレージと入出力（I/O）の仕様を考慮に入れ、ディスクおよびインデックスでデータがどのようにやりとりされるかを考慮に入れなければなりません。 -->

### 10.1.1 データベースの行ストレージ

データはブロック（or ページ）呼ばれるものに格納される。

- ブロック
  - ディスク上の特定のバイト列に対応している。
  - データを格納する最小単位
  - データのほかにメタデータを保持
    - ディスク上のアドレス情報、ブロックに対するアクティビティ情報等
  - エクステントと呼ばれる、より大きな入れものの単位で管理されることがある
- エクステント

> ![cncpt027](https://docs.oracle.com/cd/B19306_01/server.102/b14220/img/cncpt027.gif)

引用: [Data Blocks, Extents, and Segments](https://docs.oracle.com/cd/B19306_01/server.102/b14220/logical.htm)

<!-- まずは、データ構造の概要から始めます。 -->
<!-- リレーショナルデータベースにおいてデータは、ブロックもしくはページと呼ばれる入れものに格納されます。ブロックもしくはページは、ディスク上の特定のバイト列に対応しています。データベースによって用語がブロックやページだったりしますが、指しているものは同じです。 -->

<!-- ブロックはデータを格納する最小単位です。 -->
<!-- また、ブロックはデータにアクセスするさいに使用可能な最小単位です。 -->
<!-- 例えばブロックサイズが16KBだった場合、データのサイズが 1KB であったとしても、読み込みにはブロックサイズの 16KB が必要になります。 -->
<!-- データベースのブロックサイズが、ファイルシステムのブロックサイズよりも小さい場合、複数のページを無駄に消費することになり、I/O オペレーションにおいて無駄が発生することになります。 -->

<!-- ブロックは、データのほかにメタデータを保持しています。これにはヘッダやトレイラー／フッタが含まれ、ディスク上のアドレス情報、オブジェクトがどのブロックに配置されているか、そのブロックの行に対するアクティビティの情報が保存されています。 -->
<!-- データブロックは、エクステントと呼ばれる、より大きな入れものの単位で管理されることがあります。テーブル領域に、新たに割り当てが必要になった場合、効率化のためにエクステントが単位となって新しいブロックの割り当てを行います。 -->
<!-- テーブル領域は、もっとも大きいデータ構造であり、1 つまたは 2 つの物理ファイルとして、ディスク上に保存されます。 -->
<!-- システム上は物理ディスクに直接マッピングされますが、テーブル領域のファイルは I/O コストを下げるため、異なるディスクにまたがって配置されることもあります。 -->


#### バイナリツリー構造

多くのデータベースでは、データをバイナリツリー（B-tree）のフォーマットで構造化している。

- バイナリツリー構造
  - データが増え続ける場合でも自分でバランシング（二分探索）する
  - データブロックの読み書き、そしてファイルシステムやデータベース向けの構造
  - [B+tree](https://ja.wikipedia.org/wiki/B%2B%E6%9C%A8)や[B\*-tree](https://ja.wikipedia.org/wiki/B*%E6%9C%A8)といった改良版も存在する

---

※注: 本著では`バイナリツリー=B-tree`となるが、`バイナリツリー=binary tree=二分木`と`B-tree=self-balancing binary search tree=平衡二分探索木`は別物のようです。本著では、`B-tree`の意味として使われているように感じます。
参考: [B 木 - Wikipedia](https://ja.wikipedia.org/wiki/B%E6%9C%A8)

---

- バイナリツリーが持つ特性と利点
  - 範囲ベースのクエリに対して高パフォーマンス
  - 単一行ベースの検索に対しては、もっとも理想的なモデルというわけではない(後述)
  - ソートされたキーに対しては、検索と範囲スキャンは効率的に実施できる
  - 大規模データセットにおいてページの読み込みを最小に抑えられる
  - ページごとにキーを格納する必要がないので、削除と挿入が効率的に実施できる
  - バイナリツリーがメモリにすべて載る場合は、極めてよいパフォーマンスを発揮する

### 10.1.2 ストアドストリングテーブルとログ構造のマージツリー

<!-- 次に、上述したブロックストレージと異なるデータストレージ構造として、Sorted String Table（SSTable）エンジンについて紹介します。 -->

---

※注: おそらく訳ミスで、`ストアドストリングテーブル:Stored String Table`ではなく`Sorted String Table（SSTable）`

---

- SSTable
  - 以下のようなデータベースのプライマリストレージとして機能するストレージエンジン
    - Apache Cassandra
    - Google Bigtable
    - HBase
    - LevelDB
    - Lucene
    - Riak
    - RocksDB
    - WiredTiger
  - ペアとなるキーと値がソートされた多数のファイルを保持している
  - ブロックストレージとは異なり、オーバーヘッドとなるメタデータは存在しない

ストアドストリングテーブルエンジンは、

- データをすべてメモリ上に保持するインメモリテーブル
- データをひとまとめ（バッチ）にしたディスク同期（フラッシュ）
- 定期的に実行されるコンパクション

といったアルゴリズムを組み合わせて動作する。
このアルゴリズムは、**ログ構造マージ（LSM）ツリーアーキテクチャ**とも呼ばれる。

> ![10_01](https://github.com/eyuta/zenn/blob/master/out/articles/database-reliability-engineering__10_01.png?raw=true)

引用: データベースリライアビリティエンジニアリング P204

<!-- ここまで、データストレージ構造をいくつか紹介してきました。 -->

### 10.1.3 インデックスの生成

<!-- 先に紹介したバイナリツリーは、それこそデータベースではお馴染みの代表的なインデックス構造であり、SSTもその系譜です。ただ、データベースの世界には、ほかにもいくつかのインデックス構造が存在します。 -->

#### ハッシュインデックス

検索キーをハッシュ関数でハッシュ化し、その値とレコードを紐付けて格納する（=ハッシュマップ）。
検索時は、検索キーのハッシュ値に基づいてレコードを取得する。

> ![image-126.png](https://codingsight.com/wp-content/uploads/2021/06/image-126.png)

参考: [Hash Index: Everything you Need to Know about Hashing](https://codingsight.com/hash-index-understanding-hash-indexes/)

- デメリット
  - ハッシュマップ自体がメモリに載せられるサイズである必要がある
  - 単一キーでの検索となるため、範囲検索には向かない

#### ビットマップインデックス

データをビットマップの配列として保持する。
バイナリツリーインデックスと異なり、カーディナリティ（データ濃度）が低い（=取りうる値の種類が少ない）場合に有効。

#### バイナリツリーにおける並び替え

バイナリツリーインデックスの並び替え（ソート）手法には様々なものがあるが、用途によって使い分ける必要がある。

- 関数ベースの並び替え
  - 任意の関数で並び替えを行ったインデックス
- 逆インデックス
  - ソート順を逆向きにしたインデックス
- クラスタリングされたインデックス
  - I/O 最適化のためにテーブルを物理的に保存しているインデックス
  - バイナリツリーの葉ノードは、クラスタリングされたそれぞれにデータページを保持する
- 空間インデックス
  - R-Tree（R 木）がよく使われる
  - R: Rectangle
  - 多次元情報のインデックス付けに使用される
  - 参考: [空間インデックス - Wikipedia](https://ja.wikipedia.org/wiki/%E7%A9%BA%E9%96%93%E3%82%A4%E3%83%B3%E3%83%87%E3%83%83%E3%82%AF%E3%82%B9)
- サーチインデックス
  - カラム内のサブセットとしての情報を検索するのに適したインデックス
  - インデックス化された値に対して検索できる
  - 例: ElasticSearch

## 10.2 データのレプリケーション

- 単一リーダー（Single Leader）
  - リーダーが 1 つのノードのケース
  - データは常に特定のリーダーに送られる
- 複数リーダー（Multiple Leader）
  - リーダーのロール（役割）を持った複数のノードが存在するケース
  - それぞれのリーダーがクラスタを通じてデータを保持する
- リーダー不在（No Leader）
  - すべてのノードが書き込み可能



<!-- 本書は、読者が分散データベースの運用という重要な職務を担っていると想定して書かれていています。データは特定のノードで書き込まれ、ノード間で更新されている、つまりレプリケーションです。

ここでは、レプリケーションを効率化させる方法について紹介します。
DBREとしても、また、DBREとしてあなたがサポートするほかのエンジニアのためにも、レプリケーションのメソッドを正しく理解し、それがどのように動いているのかを把握しておかなければなりません。
レプリケーションにまつわる長所と短所、パターンとアンチパターンを知ることは、あなたがDBREであれ、アーキテクトであれfv、エンジニアであれ、オペレーションであれ、仕事を実りあるものにするはずです。
レプリケーションのアーキテクチャは、高いレベルにおいては違いがあり、それらは初期化時の動作によるものです。
レプリケーションを語るさいには、アプリケーションから書き込み要求を受け付けるリーダーとなるノード、そしてリーダーに追随してデータの提供を受け、それを適用するフォロワーとなるノードに分かれます。

Amazon RDS で例えると、リーダーをプライマリ DB インスタンス、フォロワーとなるノードはリードレプリカと呼ばれています。

アプリケーションは、フォロワーとなるノードから読み込みを実施し、リーダーとなるノードに書き込みを実施します。

単一リーダー（Single Leader）は、リーダーが1つのノードのケースです。
データは常に特定のリーダーに送られます。

複数リーダー（Multiple Leader）は、リーダーのロール（役割）を持った複数のノードが存在するケースです。
それぞれのリーダーがクラスタを通じてデータを保持します。

リーダー不在（No Leader）は、すべてのノードが書き込み可能です。

まずは単純な単一リーダーから紹介します
 -->

### 10.2.1 単一リーダーによるレプリケーション

### 10.2.2 複数リーダーのレプリケーション

## 10.3 まとめ
